package fr.gdd.fedqpl;

import fr.gdd.fedqpl.operators.Mj;
import fr.gdd.fedqpl.operators.Mu;
import fr.gdd.fedqpl.visitors.ReturningOpVisitor;
import fr.gdd.fedqpl.visitors.ReturningOpVisitorRouter;
import fr.gdd.fedup.transforms.Quad2Pattern;
import org.apache.jena.graph.*;
import org.apache.jena.sparql.algebra.Op;
import org.apache.jena.sparql.algebra.OpAsQuery;
import org.apache.jena.sparql.algebra.op.*;
import org.apache.jena.sparql.util.ExprUtils;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.util.Values;
import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.algebra.*;
import org.eclipse.rdf4j.query.algebra.helpers.AbstractSimpleQueryModelVisitor;
import org.eclipse.rdf4j.query.impl.ListBindingSet;
import org.eclipse.rdf4j.query.parser.ParsedQuery;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;

import java.lang.reflect.Field;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Parsing the textual SPARQL query generated by FedUP may sometimes
 * take milliseconds, seconds, or even minutes, depending on the difficulty
 * of the federated query.
 * *
 * To use FedUP with FedX, we need to remove this intermediate representation
 * when too difficult.
 */
public class FedQPL2FedX extends ReturningOpVisitor<TupleExpr> {

    private static Integer ANON_VARS = 0;
    private static final boolean SILENT = true;

    private static String getAnonName() {
        ANON_VARS += 1;
        return "_anon_" + ANON_VARS;
    }

    @Override
    public TupleExpr visit(OpTriple triple) {
        Var s = getVar(triple.getTriple().getSubject());
        Var p = getVar(triple.getTriple().getPredicate());
        Var o = getVar(triple.getTriple().getObject());
        return new StatementPattern(s, p, o);
    }

    @Override
    public TupleExpr visit(OpBGP bgp) {
        return switch (bgp.getPattern().size()) {
            case 0 -> new EmptySet();
            case 1 -> ReturningOpVisitorRouter.visit(this, new OpTriple(bgp.getPattern().get(0)));
            default -> {
                // wrote as nested unions
                Iterator<Triple> ops = bgp.getPattern().iterator();
                TupleExpr left = ReturningOpVisitorRouter.visit(this, new OpTriple(ops.next()));
                while (ops.hasNext()) {
                    TupleExpr right = ReturningOpVisitorRouter.visit(this, new OpTriple(ops.next()));
                    left = new Join(left, right);
                }
                yield left;
            }
        };
    }

    @Override
    public TupleExpr visit(OpSequence sequence) {
        return switch (sequence.getElements().size()) {
            case 0 -> new EmptySet();
            case 1 -> ReturningOpVisitorRouter.visit(this, sequence.getElements().getFirst());
            default -> {
                // wrote as nested unions
                Iterator<Op> ops = sequence.getElements().iterator();
                TupleExpr left = ReturningOpVisitorRouter.visit(this, ops.next());
                while (ops.hasNext()) {
                    TupleExpr right = ReturningOpVisitorRouter.visit(this, ops.next());
                    left = new Join(left, right);
                }
                yield left;
            }
        };
    }

    @Override
    public TupleExpr visit(OpService req) {
        Var serviceUri = switch (req.getService()) {
            case Node_Variable v -> new Var(v.getName());
            case Node_URI u -> new Var(getAnonName(), Values.iri(u.getURI()), true, true);
            default -> throw new UnsupportedOperationException("Unknown service type: " + req.getService());
        };

        Op service = ReturningOpVisitorRouter.visit(new Quad2Pattern(), req.getSubOp());

        return new Service(serviceUri,
                ReturningOpVisitorRouter.visit(this, req.getSubOp()),
                OpAsQuery.asQuery(service).toString(),
                Map.of(), // no prefix, already injected in URIs
                "", // baseURI
                SILENT);
    }

    @Override
    public TupleExpr visit(Mu mu) {
        return switch (mu.getElements().size()) {
            case 0 -> new EmptySet();
            case 1 -> ReturningOpVisitorRouter.visit(this, mu.getElements().getFirst());
            default -> {
                // wrote as nested unions
                Iterator<Op> ops = mu.getElements().iterator();
                TupleExpr left = ReturningOpVisitorRouter.visit(this, ops.next());
                while (ops.hasNext()) {
                    TupleExpr right = ReturningOpVisitorRouter.visit(this, ops.next());
                    left = new Union(left, right);
                }
                yield left;
            }
        };
    }

    @Override
    public TupleExpr visit(Mj mj) {
        return switch (mj.getElements().size()) {
            case 0 -> new EmptySet();
            case 1 -> ReturningOpVisitorRouter.visit(this, mj.getElements().getFirst());
            default -> {
                // wrote as nested unions
                Iterator<Op> ops = mj.getElements().iterator();
                TupleExpr left = ReturningOpVisitorRouter.visit(this, ops.next());
                while (ops.hasNext()) {
                    TupleExpr right = ReturningOpVisitorRouter.visit(this, ops.next());
                    left = new Join(left, right);
                }
                yield left;
            }
        };
    }

    @Override
    public TupleExpr visit(OpLeftJoin lj) {
        ValueExpr expr = null;
        if (Objects.nonNull(lj.getExprs()) && !lj.getExprs().isEmpty()) {
            expr = getValueExpr(String.join("&&",
                    lj.getExprs().getList().stream().map(ExprUtils::fmtSPARQL).toList()));
        }
        return new LeftJoin(ReturningOpVisitorRouter.visit(this, lj.getLeft()),
                ReturningOpVisitorRouter.visit(this, lj.getRight()),
                expr);
    }

    @Override
    public TupleExpr visit(OpConditional cond) {
        return new LeftJoin(ReturningOpVisitorRouter.visit(this, cond.getLeft()),
                ReturningOpVisitorRouter.visit(this, cond.getRight()));
    }

    @Override
    public TupleExpr visit(OpDistinct distinct) {
        return new Distinct(ReturningOpVisitorRouter.visit(this, distinct.getSubOp()));
    }

    @Override
    public TupleExpr visit(OpProject project) {
        return new Projection(ReturningOpVisitorRouter.visit(this,project.getSubOp()),
                new ProjectionElemList(project.getVars().stream().map(v -> new ProjectionElem(v.getVarName())).toList()));
    }

    @Override
    public TupleExpr visit(OpGroup groupBy) {
        if (!groupBy.getAggregators().isEmpty()) { // TODO
            throw new UnsupportedOperationException("Group by aggregators…");
        }
        return new Group(ReturningOpVisitorRouter.visit(this, groupBy.getSubOp()),
                groupBy.getGroupVars().getVars().stream().map(Node_Variable::toString).collect(Collectors.toList()));
    }

    @Override
    public TupleExpr visit(OpSlice slice) {
        return new Slice(ReturningOpVisitorRouter.visit(this, slice.getSubOp()),
                slice.getStart(),
                slice.getLength());
    }

    @Override
    public TupleExpr visit(OpFilter filter) {
        return new Filter(ReturningOpVisitorRouter.visit(this, filter.getSubOp()),
                getValueExpr(
                        String.join("&&",
                                filter.getExprs().getList().stream().map(ExprUtils::fmtSPARQL).toList())));
    }

    @Override
    public TupleExpr visit(OpOrder orderBy) {
        return new Order(ReturningOpVisitorRouter.visit(this, orderBy.getSubOp()),
                orderBy.getConditions().stream().map(sc->
                    new OrderElem(getValueExpr(ExprUtils.fmtSPARQL(sc.getExpression())))
                ).toList());
    }

    @Override
    public TupleExpr visit(OpTable table) {
        Set<ListBindingSet> bindingsForFedx = new HashSet<>();
        table.getTable().rows().forEachRemaining(binding -> {

            List<Value> actualValues = new ArrayList<>();
            binding.vars().forEachRemaining(v -> {
                Node valueAsNode = binding.get(v);
                Value value = Values.iri(valueAsNode.getURI());
                actualValues.add(value);
            });
            List<String> varsNames = binding.varsMentioned().stream().map(org.apache.jena.sparql.core.Var::getVarName).distinct().collect(Collectors.toList());
            ListBindingSet oneBindingSet = new ListBindingSet(varsNames, actualValues);
            bindingsForFedx.add(oneBindingSet);
        });
        BindingSetAssignment valuesForFedX = new BindingSetAssignment();
        valuesForFedX.setBindingSets(Collections.unmodifiableSet(bindingsForFedx));
        return valuesForFedX;
    }

    /* ********************************************************************* */

    public static ValueExpr getValueExpr(String ExprAsSPARQL) {
        // TODO This is particularly ugly to get the filter condition in
        //      terms of FedX since nothing is set to parse the expression alone
        //      and get a `ValueExpr` to create the `Filter` operator…
        ParsedQuery parsedQuery = QueryParserUtil.parseQuery(QueryLanguage.SPARQL,
                "SELECT * WHERE {?s ?p ?o FILTER (" + ExprAsSPARQL + ")}",
                null);

        ValueExpr expr = null;
        try {
            parsedQuery.getTupleExpr().visit(new ValueExprGetterVisitor());
        } catch (ValueExprGetterVisitor.ValueExprException e) {
            expr = e.expr;
            // ((AbstractQueryModelNode) expr).setParentNode(null);
            // TODO very very ugly. But we need to put parent to null otherwise it
            //      does not pass an assert in `setParentNode`. Could also disable runtime assertions as
            //      it probably should in release mode anyway.
            try {
                Field privateField = AbstractQueryModelNode.class.getDeclaredField("parent");
                privateField.setAccessible(true);
                privateField.set(expr, null);
            } catch (Exception exception) {
                throw new RuntimeException(exception.getMessage());
            }
        }
        return expr;
    }

    /**
     * @param node The node to convert.
     * @return A FedX Var from a Jena Node.
     */
    private static Var getVar(Node node) {
        return switch (node) {
            case Node_Literal lit -> new Var(getAnonName(), Values.literal(lit.getLiteralLexicalForm()), true, true);
            case Node_URI uri -> new Var(getAnonName(), Values.iri(uri.getURI()), true, true);
            case Node_Variable var -> new Var(var.getName());
            default -> throw new UnsupportedOperationException(node.toString());
        };
    }

    /* ************************************************************************************* */

    /**
     * An RDF4J visitor that will probably be useful nowhere else. If this happens, consider moving
     * it to its own file…
     */
    public static class ValueExprGetterVisitor extends AbstractSimpleQueryModelVisitor<RuntimeException> {

        @Override
        public void meet(Filter node)  {
            throw new ValueExprException(node.getCondition());
        }

        /**
         * The exception that goes with the Visitor. It's actually the return value, and
         * not an actual exception. This is probably the proper way to use these RDF4J visitors.
         */
        public static class ValueExprException extends RuntimeException {

            ValueExpr expr;

            public ValueExprException(ValueExpr expr) {
                this.expr = expr;
            }
        }

    }

}
